"use strict";const Impl=(()=>{function a(v,w){const y=Array.isArray(this.depth),z=y?this.depth:Array(w.length).fill(this.depth);m(!y||z.length===w.length,l,"Wrong depths array length:",z,w),y||(v+=String.fromCodePoint(n(w.length)));let A=0,B=0;for(let C=0,D=w.length;C<D;++C){const E=w[C],F=z[C];for(let G=0;G<F;){const H=e-A,I=F-G,J=Math.min(H,I);let K=Math.floor(E/h[G]);K%=h[J],K*=h[A],B+=K,G+=J,A+=J,A===e&&(v+=String.fromCodePoint(n(B)),A=B=0)}}return 0!==A&&(v+=String.fromCodePoint(n(B))),v}function b(v,w){m(!this.meta||0<w.depth||0===w.depth&&Array.isArray(this.depth),l,"Array decoding error (check inputs and codec config)"),w.depth=w.depth||this.depth;const y=Array.isArray(w.depth);let z=0,A=0;const B=y?w.depth.length:p(v.codePointAt(z++)),C=y?w.depth:Array(B).fill(w.depth),D=Array(B);for(let E=0,F=p(v.codePointAt(z++));A<B;){const G=C[A];let H=0,I=0;for(;I<G;){const J=e-E,K=G-I,L=Math.min(J,K);let M=Math.floor(F/h[E]);if(M%=h[L],M*=h[I],H+=M,I+=L,E+=L,E===e){if(A+1===B&&I===G)break;F=p(v.codePointAt(z++)),E=0}}0<I&&(D[A++]=H)}return[D,z]}const c=53,e=15,f=48,h=[1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,8388608,16777216,33554432,67108864,134217728,268435456,536870912,1073741824,2147483648,4294967296,8589934592,17179869184,34359738368,68719476736,137438953472,274877906944,549755813888,1099511627776,2199023255552,4398046511104,8796093022208,17592186044416,35184372088832,70368744177664,140737488355328,281474976710656,562949953421312,1125899906842624,2251799813685248,4503599627370496,9007199254740992],j=h[e];class k extends RangeError{constructor(v){super("[utf15][RangeError]: "+v)}}class l extends TypeError{constructor(v){super("[utf15][TypeError]: "+v)}}const m=(v,w,...y)=>{if(!v)throw new w(y.reduce((z,A)=>z+A+" ",""))},n=v=>{return v=+v,m(0<=v&&v<j,k,"x out of bounds:",v),v+=f,v},p=v=>{return v=+v,m(0<=v&&v<=65535,k,"x out of bounds:",v),v-=f,v},q=v=>{let w=!1;if(w=w||isNaN(v.meta)||0!==v.meta&&1!==v.meta,w=w||isNaN(v.array)||0!==v.array&&1!==v.array,w||(()=>{const y=Array.isArray(v.depth);if(w=w||y&&!v.array,!w){const z=A=>isNaN(A)||0>=A||A>c;y?v.depth.forEach((A,B)=>{v.depth[B]=+v.depth[B],w=w||z(A)}):(v.depth=+v.depth,w=w||z(v.depth))}})(),w){let y="[JSON.stringify() ERROR]";try{y=JSON.stringify(v)}finally{}m(0,l,"Codec config is invalid:",y)}},r=(v,w)=>{const y=Array.isArray(w.depth)?0:w.depth;return v+String.fromCodePoint(n(w.array),n(y))},t=(v,w,y)=>{return y=y||0,w.array=p(v.codePointAt(y)),w.depth=p(v.codePointAt(y+1)),[v.slice(y+2),2]};return{Codec:class{constructor(v){v=v||{},this.meta=+!!v.meta,this.array=+!!v.array,this.depth=v.depth||c,q(this)}encode(v){m(+Array.isArray(v)^!this.array,l,"Incompatible codec (array <=> single value), arg =",v);let w="";if(this.meta&&(w=r(w,this)),this.array)w=a.call(this,w,v);else{let y=+v%h[this.depth];const z=Math.ceil(this.depth/e);for(let A=0;A<z;++A){const B=n(y%j);w+=String.fromCodePoint(B),y=Math.floor(y/j)}}return w}decode(v,w){let y=null,z=0;if(this.meta?[v,z]=t(v,y={}):y=this,m(y.array^!this.array,l,"Incompatible codec (array <=> single value), str =",v),this.array){const D=b.call(this,v,y);return!w||(w.length=z+D[1]),D[0]}let A=0,B=0;const C=Math.ceil(y.depth/e);for(let D=0;D<C;++D){const E=p(v.codePointAt(D));A+=E*h[B],B+=e}return!w||(w.length=z+C),A}},MAX_DEPTH:c}})();module.exports=Impl;